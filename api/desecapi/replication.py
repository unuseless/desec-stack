import os
import subprocess
from datetime import datetime, timedelta

import dns.query
import dns.zone
from celery import shared_task

from desecapi import models


class ReplicationException(BaseException):

    def __init__(self, message, **kwargs):
        super().__init__(message)
        for k, v in kwargs.items():
            self.__setattr__(k, v)


class GitRepositoryException(ReplicationException):
    pass


class UnsupportedZoneNameException(ReplicationException):
    pass


class Repository:

    def __init__(self, path):
        self.path = path

    def _git(self, *args):
        cmd = ['/usr/bin/git'] + list(args)
        print('>>> ' + str(cmd))

        with subprocess.Popen(
                cmd,
                bufsize=0,
                cwd=self.path,
                stderr=subprocess.PIPE,
                stdout=subprocess.PIPE,
        ) as p:
            rcode = p.wait()
            stderr = p.stderr.read()
            stdout = p.stdout.read()
            try:
                stderr, stdout = stderr.decode(), stdout.decode()
            except UnicodeDecodeError:
                GitRepositoryException('git stdout or stderr was not valid unicode!', cmd=cmd, stderr=stderr, stdout=stdout)

        if rcode != 0:
            raise GitRepositoryException(f'{cmd} returned nonzero error code', cmd=cmd, rcode=rcode, stdout=stdout, stderr=stderr)

        print('\n'.join(['<<< ' + s for s in stdout.split('\n')]))
        return stdout

    def commit_all(self, msg=None):
        self._git('add', '.')
        if self._git('diff', '--numstat', '--staged'):
            self._git('commit', '-m', msg or 'update')

    def init(self, name='deSEC', email='git@desec.internal'):
        self._git('init')
        self._git('config', 'user.name', name)
        self._git('config', 'user.email', email)
        # TODO on commit, git tries to access $HOME/.config/git
        #  but due to celery privilege drop, $HOME is still /root
        #  and this gives a 'permission denied' warning in the log

    def get_head(self):
        return self.get_commit('HEAD')

    def get_commit(self, rev):
        try:
            commit_msg = self._git('show', rev, '--format=%s', '-s')[:-1]
            commit_hash = self._git('show', rev, '--format=%H', '-s')[:-1]
            return commit_msg, commit_hash
        except GitRepositoryException as e:
            return None, None

    def remove_history(self, before: timedelta):
        rev = self._git('log', f'--before={(datetime.now() - before).isoformat()}', '-1', '--format=%H')
        with open(os.path.join(self.path, '.git', 'shallow'), 'w') as f:
            f.writelines([rev])
        self._git('reflog', 'expire', '--expire=now', '--all')
        self._git('gc', '--prune=now')


class ZoneRepository(Repository):
    AXFR_SOURCE = '172.16.1.11'

    def __init__(self, path):
        super().__init__(path)
        if not os.path.exists(os.path.join(self.path, '.git')):
            self.init()
            self.commit_all(msg='Inception or Recovery')
            self.full_refresh()
            self.commit_all(msg='Full Refresh')

    def full_refresh(self):
        print('WARNING: Full refresh of replication zone repository!')
        for name in models.Domain.objects.values_list('name', flat=True):
            self.refresh(name)

    def refresh(self, name):
        if '/' in name or '\x00' in name:
            raise UnsupportedZoneNameException

        # obtain AXFR
        timeout = 60  # if AXFR take longer, the timeout must be increased (see also settings.py)
        t = datetime.now()
        xfr = list(dns.query.xfr(self.AXFR_SOURCE, name, timeout=timeout))
        print(f'AXFR took {(datetime.now() - t).total_seconds():.3f}s')
        t = datetime.now()
        z = dns.zone.from_xfr(xfr)
        print(f'Parsing took {(datetime.now() - t).total_seconds():.3f}s')

        # TODO sort AXFR? (but take care with SOA)
        # TODO do not parse AXFR to save time

        # write zone file
        filename = os.path.join(self.path, name + '.zone')
        with open(filename + '~', 'w') as f:
            f.write(f'; Generated by deSEC at {datetime.utcnow()}Z\n')  # TODO if sorting, remove this to avoid overhead
            z.to_file(f)
        os.rename(filename + '~', filename)


ZONE_REPOSITORY_PATH = '/zones'


@shared_task(queue='replication')
def update(name: str):
    print(f'updating {name}')
    zones = ZoneRepository(ZONE_REPOSITORY_PATH)
    zones.refresh(name)
    zones.commit_all(f'Update for {name}')
    # TODO update DB to indicate successful replication


@shared_task(queue='replication', priority=9)
def rotate_signatures():
    names = models.Domain.objects.all().values_list('name', flat=True)
    # TODO restrict rotation to domains that weren't published since last pdns rotation occured
    print(f'Starting signature rotation for {len(names)} zones.')
    for name in names:
        update.s(name).apply_async(priority=1)
